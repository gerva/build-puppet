#!/usr/bin/env python
### Compressed module sources ###
module_sources = [('util', 'eJxlkM0KwjAQhO99iqWnClJQigfBl/AsSNJsmwWblOzWvr5N4l81t2RnZ+YLDaMPAlaxvZHegian\nuCUqCoMdsFU7lkCur3hzLGA55RllCg7EYhqnVfBdfkha4DJJQ1Y+veuoXmxqQz2yVJscoQ/NnzeD\nVoyHBtC13qDZwkxiQRTdov1sSZBH1SIoZ+C0BA3+jmaV+gKp9V5ds10MD7HiWJWniys/DRLnNPwW\n4QS17gJ3DEzevZHzaryusRPY9/8tcQ8W+3WH\n'), ('util.file', 'eJzNVk1v4zYQvftXTF0EkQNXbYz2soAPRVpgCxTbYre3xcKhRcriRiIFkoqTf983pL4iZ/ewp/Uh\ndjgzj/Nm3oy0Xq/fqrpVjsrOFEFb4ylYqoSRtaJS44+FVUTLer1e6aa1LlBtTydtTluyfku+6oKu\nt4jyVa2PWwqqaTl2VTrb0J01pT79K5zHNX38e3GeH6+AR/sBNT+p8Dd+KpcdDkY06nDYrFZSlVTY\nphVOZQx+u4357TZvVoQPkuutYFApuJqgTPBkSwpnG32Rayu8V5K0IaXh5kj4GI4PiJpEOdFHKMxF\nobzXx6EarQiVz+kPC7MgDzqg2QMYoR8V+eDAoU9Ve2tQIEvSkrGBOo+CGqqFO3HNOSeuKkfrkrTX\nxgdhipHhUXiVAHua/Ik2lIsTHhyv3fWW/nOd2nwBbPcVsN0cbHcBFq84jAXdp4PcKSGzyWO39NjN\nPZwKnTMXUPtFaGqz1E4VwbpnaCQI0MjGExSzK0v9NHWd3ifogHyZNzf/hEaYCSaKgXGisXX2UUuI\n4KxrWQgnI1KC3XJLNdrDU3Bfeyqt/fnmKNw9DX2qdABBYZ6zj2WujPRnCCnrs4I/2srysj6vtQ/I\nYUp+82nsDosBSFMfoP1cOWddtr6zXS2jR6mNpJsrz4BXfk1XlA15TqAvCgzMYVTaZ65t5l0Bbx+2\n8aixUu1ja8cC3uGY4MWUo1+LGVLukVWM2W809M97AUNBQTcQvi5HLMgsKmWoTtoF+cXtI/EhcGI+\nC2HDImThAUWHmUek6itx67smKydOgybQ7g9vf//pNu6muAoWqyEO9X15v+USV+qJG9iIMDYbre7X\nWs7XDHpvx4nhaTlep+NzxWhcjondsbbFA09Em8bht9vdze0vu18ndr0aouMUF2MR8TCeVHnXShFU\nFj1fdj1H6lKfMN7ZUBRRqkNnam0e4ljzHp3qkww0GEifjHWGOx416IdBiuWRWHbmOpB6gqCHygT3\n/GZOAXrn3Zhrz5Jf3DguG0yHszZE+fq0wH0/LWdRT5niGWJbac9mrtUlUpyzCHFpn7rU5/XZapOl\nu8vNq+4vKtZe+gDJNUyOUSazqr16eT8cl4WPdvVUqDbQPx/+5BpvaRb2I/3FHVC0fmexioqqf/a6\nac7X82or3hXG8gLdvbw8KeIr2TmhvZppZDGqkNAkE3aon+PMjhsCDniMsVREfNBbJ7BhNUbKNUpq\nCDRtigob2DF7uCbFpOBBQKVEk5s2ym8/vjLkzYPn37w090Pv8Jvdspjc5rU9Y4+fsziPkUScSH43\nyUuZphR3XZ9xeBE87ZM+l+TBvY6dy/rjvjKrVLjaCsnPLLzALKWeTsFo8YqTzTYgn6Zt8HGI/rSh\nH/Y0/Tv1rB/xd9ao+cgnlD4fvDAN6aQvPMdUfJ1DFdr0DT/R1UNzpzyw3g69c9Z/b2IHZ/aEkS0w\nNxdJ9iFI58J3nnufykXyB6joeyHAqXwTh6O19fdCgnNR4jLkNSL/A0blzyc=\n'), ('util.commands', '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\nD6Mr0w==\n'), ('util.retry', 'eJyNVsuu2zYQXVdfMXBxYdkVBN8ANwsjLlIUTVCgyCrLADYlUTYRiXT5iHNR9N87Q1LUw25RL2xy\nODycMzwzpuivSluwoudZq1UPrZO1VaozIMLSTbOryeLEalbzitVfs8HSqfNZyHOGv3AYZuWZ2z9w\nyHV+PErW8+Nxk2UNb0Fzq19zVluhZAHMWt5frTm8FGA6zq8Ux+HtroCefT+Olpct2fzeI/9ek1VJ\nc8h/G8bFpsggfeqOM+muh09KcjxEn9F1U8DXmx/+9fdm751Xq9WvrOvgFMJZA6NjRe96UC1aY3Br\nnx0DTlrRgbBgXF1z3pjxSGTGXGeROVgFLyWcUuxrEAbshYN0fcU1IRteK9kYcr0xYbMfKm5vnMuU\njmIB+HYHTDbQKFd1ZOKsvoRsDFsKdEvRzGnMMrkuAU7LPPoQGVh37ThuSTgpu0SAIe+Lcl0DFYea\nufPFlvB7CyMMKKSpyVXilzI8AXXCWN6AkI/OZpqDZsKggxfgcBsFZe0VbgJvqBqxoqvoe94IZnn3\n6sM4xTv3XK5afRMNelHWarxiViEzvDkCS0ieR9fNwYC1FkkghcSeEAfCnxTJyfVcWpOAYohwZYZC\nwwsTITevyulBjKGwCE7zP53QKKh7JAwRD9OoD4xIEgOfeMTxZejXJQU3bO24MQm5TDgnEvra0z8F\n1Yc8D5fs1SRqSwJJUVDgRAGUnIgJjachhWusGL9ARLH2B3us5810TSqbqCs9ukZb8BXtvNDh3dgG\n9qN81LlseOXO+Wru/dSAT4CX3NS8gifIZ76T/rIJZ0tsV89+dLsIzImEd4dUgePhKNf9pLWEaIRs\nVb7yWt4D9RCqyieDSrAX32/2OBsaThhHZPgxRPdlhgmQWqKxOqddmzAMEDiRMexUB9w6jULw2/It\neRWw3Ub/5Boq7a513lOKCU6cSO9jce9hVdDsSMwPn7Xj82jwIuPF7hfEUjfO73bgDTzK+L8m+qP4\nRnkmQUnMKaVxKrxZdqhLLM8bFfIz7P7HeR8Y6qKJyvE33KTeXfFWUeMiT1yiWEaB3UGTtfTr+X94\njfEdJuMtvLnzXJCZKf2e2BJ75j7zRm74n+NGYyskqntRARJ+otJJ/+fCF/Y2aGwQYphFOYb96/Ua\nfsG/tlppZrEnYAbje2BTYrtlPbUmZ9g5cng/godk0YGtUhMllWWZLX3To+J5t5s+K553I0rFdL7Z\nz2BihFnyOSbIY4s6UxgnddrJtvf+bRSs07fAdCu5XPEdtKzQ/aNqDtkgvPhsCZviwyX8IMYk0w8v\n238WV5AtjroPMXu8Grln/wDA0B8t\n'), ('unix_util', 'eJx1UDtvwjAQ3v0rTpmCFFnt0KVShw4IImiQSqQOiCEKB5zqYOtsmvLve3kRMvS2++572VQ5ywE8\nnS6FScD6BAJVqNQBj/BNxsSODrNXBTJRFK0EAce2RO9BLlBTODfAiQWhHzQ3qCwjFAPQW3st6tZF\ndkM+wBvsupPepos0yxMY13z++bFv2fWZDELOV+w6NEPHwWTEemdx7U/aWRc/ze4ENB7/ofehq3S9\nvhOs18Pr22KjUfM92htEF7+MKJfiJaK6oCCaTif7V7ZZvmeLBznfpjUmSY+Ff0t0ATbbObPlqYYx\nXPkiobvnvVJ/vQN96w==\n')]

### Load the compressed module sources ###
import sys, imp
for name, source in module_sources:
    source = source.decode("base64").decode("zlib")
    mod = imp.new_module(name)
    exec source in mod.__dict__
    sys.modules[name] = mod

### Original script follows ###
#!/usr/bin/env python
"""retry.py [options] cmd [arg arg1 ...]

Retries cmd and args with configurable timeouts and delays between retries.

Return code is 0 if cmd succeeds, and is 1 if cmd fails after all the retries.
"""

import time, subprocess, logging, os, sys, re
from tempfile import TemporaryFile
from operator import xor
log = logging.getLogger()

sys.path.append(os.path.join(os.path.dirname(__file__), "../../lib/python"))

from util.retry import retry

if sys.platform.startswith('win'):
    from win32_util import kill, which
else:
    from unix_util import kill

def read_file(f):
    f.seek(0)
    return f.read()

def search_output(f, regexp, fail_if_match):
    res = re.search(regexp, read_file(f))
    return xor(bool(res), fail_if_match)

class RunWithTimeoutException(Exception):
    def __init__(self, rc, **kwargs):
        Exception.__init__(self, **kwargs)
        self.rc = rc

def run_with_timeout(cmd, timeout, stdout_regexp=None, stderr_regexp=None,
                     fail_if_match=False, print_output=True):
    if stdout_regexp:
        stdout = TemporaryFile()
    else:
        stdout = None
    if stderr_regexp:
        stderr = TemporaryFile()
    else:
        stderr = None
    proc = subprocess.Popen(cmd, stdout=stdout, stderr=stderr)
    start_time = time.time()
    log.info("Executing: %s", cmd)
    while True:
        rc = proc.poll()
        if rc is not None:
            log.debug("Process returned %s", rc)
            if print_output and stdout:
                print "Process stdio:\n%s" % read_file(stdout)
            if print_output and stderr:
                print "Process stderr:\n%s" % read_file(stderr)
            if rc == 0:
                if stdout_regexp and not \
                   search_output(stdout, stdout_regexp, fail_if_match):
                    raise RunWithTimeoutException("%s found in stdout, failing" % fail_if_match, -1)
                if stderr_regexp and not \
                   search_output(stderr, stderr_regexp, fail_if_match):
                    raise RunWithTimeoutException("%s found in stderr, failing" % fail_if_match, -1)
                return rc
            else:
                raise RunWithTimeoutException("command exited with non-zero return code %d, failing" % rc, rc)

        if start_time + timeout < time.time():
            log.warn("WARNING: Timeout (%i) exceeded, killing process %i",
                     timeout, proc.pid)
            rc = kill(proc.pid)
            log.debug("Process returned %s", rc)
            raise RunWithTimeoutException("Timeout (%i) exceeded" % timeout, rc)

        # Check again in a sec...
        time.sleep(0.25)

if __name__ == "__main__":
    from optparse import OptionParser

    parser = OptionParser(__doc__)
    parser.disable_interspersed_args()

    parser.add_option("-r", "--retries", type="int", dest="retries",
                      help="""retry this many times.  Set 0 to retry forever.
                      Defaults to 10""")
    parser.add_option("-t", "--timeout", type="int", dest="timeout",
                      help="""timeout each request after this many seconds.  Set
                      to 0 to have no timeout.  Defaults to 300""")
    parser.add_option("-s", "--sleeptime", type="int", dest="sleeptime",
                      help="""sleep this many seconds between tries, doubling
                      each retry iteration.  Defaults to 30""")
    parser.add_option("-m", "--maxsleeptime", type="int", dest="maxsleeptime",
                      help="""when doubling sleeptime, do not exceed this value.
                      Defaults to 300""")
    parser.add_option("--stdout-regexp", dest="stdout_regexp",
                      help="""Fail if the expected regexp is not found in
                      stdout""")
    parser.add_option("--stderr-regexp", dest="stderr_regexp",
                      help="""Fail if the expected regexp is not found in
                      stderr""")
    parser.add_option("--fail-if-match", dest="fail_if_match",
                      action="store_true", default=False, help="""Reverse the
                      meaning of stderr-regexp/stdout-regexp and fail if the
                      expected regexp is NOT found in the output""")
    parser.add_option("--no-output", dest="print_output",
                      action="store_false", default=True,
                      help="Don't print stdout/stderr output")

    parser.set_defaults(
            retries=10,
            timeout=300,
            sleeptime=30,
            maxsleeptime=300,
            )

    options, args = parser.parse_args()

    if len(args) == 0:
        parser.error("Command argument missing")

    logging.basicConfig(level=logging.INFO, format="%(message)s")
    # Another dirty hack... :(
    # Special care for programs w/o extensions on Windows
    if sys.platform.startswith('win') and  not os.path.splitext(args[0])[1]:
        args[0] = which(args[0])

    try:
        rc = retry(run_with_timeout, attempts=options.retries,
                   sleeptime=options.sleeptime, max_sleeptime=options.maxsleeptime,
                   args=(args, options.timeout, options.stdout_regexp,
                         options.stderr_regexp, options.fail_if_match,
                         options.print_output))
        sys.exit(rc)
    except KeyboardInterrupt:
        sys.exit(1)
    except Exception, e:
        log.info("Unable to successfully run %s after %d attempts" % \
          (args, options.retries))
        # If we caught a RunWithTimeoutException we can exit with the same
        # rc as the command. If something else was hit, just exit with 1
        rc = getattr(e, 'rc', 1)
        sys.exit(rc)
